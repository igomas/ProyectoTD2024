---
title: "ProyectoTD2024 Grupo F"
author: Maria Castellanos, Pablo Pons, Irene Gómez, Jenny Carolina Matamoros, Andreu
  Herrero, Álvaro Cruz
date: "2024-03-26"
output:
  word_document: default
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Introduccion

El conjunto de datos que vamos a utilizar para el análisis de nuestro proyecto pertenecen al supermercado Mercadona. En concreto, son tickets de los usuarios que realizan sus compras en dicho supermercado, que tiene como propósito informar de las compras de dichos usuarios.

En nuestro caso, hemos decidido hacer la exploración de las horas más concurridas, de la evolución del precio de los productos, del método de pago, del precio medio de la compra y de la media de la cantidad de los productos comprados.

# Preguntas


1.  A qué hora se suele ir más a comprar?
2.  Cuál ha sido el producto más comprado?
3.  En que Mercadona se realizan más ventas?
4.  Cual es el precio medio de los tickets?
5.  En que mes se ha comprado más "x producto"?
6.  ¿Cómo ha variado el precio promedio de los productos más vendidos en los últimos meses?

```{r warning=FALSE}
#Haremos la importacion de los datos
#descargaremos las librerias que necesitamos
#install.packages("pacman")
library(pacman)
p_load(readr, dplyr,tidyr,stringr)
#library(readr)
#library(dplyr)
#library(tidyr)

#Primero vamos a guardar en una variable la ruta donde se encuentra la carpeta con todos los ficheros que utilizaremos
carpeta_ruta <- ".\\data"

#Ahora declararemos una variable donde usaremos el codigo list.files para obtener una lista de archivos dentro de la carpeta de la cual solo vamos a seleccionar los archivos que sean .txt
archivos_texto <- list.files(path = carpeta_ruta , pattern = "\\.txt$", full.names = TRUE)

#crearemos una lista donde almacenaremos los datos de cada archivo
datos <- list()

#iniciaremos un bucle, el cual iterara con todos los archivos en la lista de archivos
for (archivo in archivos_texto) {
  # Leeremos las líneas del archivo
  lineas <- read_lines(archivo, locale = locale(encoding = "latin1")) #ponemos el encoding correspondiente
  
  #Los datos que nos interesan del ticket son los que se encuentran hasta la linea donde nos indica el precio total de la compra realizada, 
  #por lo que pondremos que busque la palabra    
  #TOTAl, en la cual nos devolvera el numero donde se encuentra en cada archivo
  pos_total <- grep("TOTAL", lineas)
  
  #si no se encuentra la palabra "TOTAL" pasaremos al siguiente archivo
  if (length(pos_total) == 0) next
  
  #ahora haremos que cada archivo solo  vaya hasta la posicion donde se encuentra TOTAL
  lineas <- lineas[1:(pos_total)]
  
  #eliminaremos las líneas en blanco o vacías
  lineas <- lineas[lineas != ""]
  
  #como en todos los archivos las primeras lineas contienen la misma informacion,extraemos la      información
  empresa <- lineas[1]
  direccion <- lineas[2]
  ciudad <- lineas[3]
  
  #ajustaremos la forma en la que guarda los datos en la columna Telefono
  telefono_linea <- lineas[grep("TELÉFONO:", lineas)]
  telefono <- substring(telefono_linea, regexpr(":", telefono_linea) + 1)
  
  fecha <- lineas[5]
  
  #ajustaremos la forma en la que guarda los datos en la columna Factura
  factura_linea <- lineas[grep("FACTURA SIMPLIFICADA:", lineas)]
  factura <- substring(factura_linea, regexpr(":", factura_linea) + 2)
 
  descripcion <- lineas[7]
  
  #aqui indicamos que la variable cantidad va desde la linea 8 hasta la penultima de las 
  #lineas que hemos leido de cada archivo, ya que no todos los tickets contienen la misma 
  #cantidad de productos comprados
  rango <- 8:(length(lineas)-1)
  cantidad <- lineas[rango]
  
  
  #aqui indicamos que el total de la compra se encuentra en la ultima linea de cada archivo
  rango_total <- length(lineas)
  total <- lineas[rango_total]
  
  #almacenaremos la información en un data temporal
  data1_temporal <- data.frame(Empresa = empresa,
                            Direccion = direccion,
                            Ciudad = ciudad,
                            Telefono = telefono,
                            Fecha = fecha,
                            Factura = factura,
                            Cantidad = cantidad,
                            Total = total
                            )


  
  #añadiremos el data temporal a la lista de datos
  datos[[length(datos) + 1]] <- data1_temporal
}

#uniremos todos los datas en uno solo 
data1 <- bind_rows(datos)
#vamos a separar la columna Ciudad en dos , donde una se llamara codigo postal y otra ciudad
data1<- separate(data1, Ciudad, into = c("codigo_postal", "ciudad"))
#aqui hemos hecho lo mismo pero con la columna Fecha la cual hemos separado en fecha y hora
data1 <- separate(data1, Fecha, into = c("fecha", "hora"), sep = "(\\s+|\\s+OP:\\s+)")
df <- as.data.frame(data1)

#Como nos podemos fijar en el data frame la variable de cantidad, no esta ajustada de una forma que nos facilite su importacion en el caso de un futuro analisis, por lo que deberemos ajustarla
#nos fijamos en que las lineas siguen un formato, estan las cantidades del producto y el producto unidas, por lo que usaremos la funcion gsub para que añada una "/" al principio para que cuando lea y vea que hay un numero seguido de una letra la añada
datos_cantidades <- gsub("(\\d+)([A-Z])", "\\1/\\2", data1$Cantidad)
#asignaremos la nueva forma a la variable del dataframe
data1$Cantidad <- datos_cantidades
#ahora nos fijamos en que no todas las lineas tiene un numero y una letra justo detras, sino que tiene un numero seguido de un espacio en blanco, haremos lo mismo 
datos_cantidades2 <- gsub("^([0-9]+) ", "\\1/ ", data1$Cantidad)
#asignaremos la nueva forma a la variable del dataframe
data1$Cantidad <- datos_cantidades2
#ahora podemos usar la funcion separate para poder separar la columna cantidad en dos, la cual una es cantidad y la otra producto, lo cual nos resultara mas facil ya que todos tienen un patron con /
data1 <- separate(data1, Cantidad, into = c("Cantidad", "Producto"), sep = "/", extra = "merge")

#ahora cambiaremos las comas por los puntos
producto1 <- gsub(",", ".", data1$Producto)
#asignaremos el nuevo formato 
data1$Producto <- producto1

#ahora nos encargaremos de separar la variable producto en producto y precio, ya que como se puede observar ambos estan unidos
producto_editado <- gsub(" ([0-9]+\\.[0-9]+)$", " /\\1", data1$Producto, perl = TRUE)
#lo asignaremos al dataframe
data1$Producto <- producto_editado

#usaremos la funcion de str_detect para hallar los indices de las filas donde se encuentra "kg" lo cual lo tomaremos como referencia para encontrar la fila que equivale al precio por kilo de las frutas que se encuentran en la columna "Cantidad"
indices2_kg <-  which(str_detect(data1$Cantidad, "kg"))
#guardaremos en una variable los valores que se encuentran en cada indice de la columna Cantidad
precios2_kg <- data1$Cantidad[indices2_kg]
#eliminar el final
precios2_kg <- gsub("\u0080", "", precios2_kg)
#Como se puede observar la fruta correspondiente al precio por kilo se encuentra en la fila anterior, por lo que haremos una variable con todos esos indices menos uno (anterior)
indice_anterior_kg <- indices2_kg - 1

#guardaremos todos los datos de las frutas en una variable 
producto_2 <- data1$Producto[indice_anterior_kg]
#procederemos a unir las variables de producto_2 y precio2_kg
producto_completo <- paste(producto_2, precios2_kg, sep = ", ")
#asignaremos a las filas de cada producto segun el indice en que localizamos donde estaban los nuevos productos completos
data1$Producto[indice_anterior_kg] <- producto_completo

#y como hemos conseguido que sigan un patron lo aprovecharemos para separarlo siguiendo dicha patron
data1 <- separate(data1, Producto, into = c("Producto", "Precio_Final"), sep = "/(?=[^/]+$)", extra = "merge")

#ajuste producto pollo y conejo
palabra1 <- "TROCEADO"
palabra2 <- "PARTIDO"
medio_troceado <- which(str_detect(data1$Producto, paste(palabra1, palabra2, sep = "|") ))

cantidad_medio_troceado <-data1$Cantidad[medio_troceado] 

producto_medio <- data1$Producto[medio_troceado]

filtrados <- ifelse(nchar(cantidad_medio_troceado) > 1, substr(cantidad_medio_troceado, 1, nchar(cantidad_medio_troceado) - 1), cantidad_medio_troceado)
 
ultimos <- ifelse(nchar(cantidad_medio_troceado) > 1, substr(cantidad_medio_troceado, nchar(cantidad_medio_troceado), nchar(cantidad_medio_troceado)), NA)

data1$Cantidad[medio_troceado] <- filtrados
na_indices <- which(!is.na(ultimos))
data1$Producto[medio_troceado[na_indices]] <- paste(ultimos[na_indices],data1$Producto[medio_troceado[na_indices]], sep = "")

#Visualizando el data frame, se han encontrado algunos errores, por ejemplo en las variables de Cantidad y Producto nos hemos encontrado con alguna fila con los datos de parking de entrada y salida, como en un principio se llego a la idea de no usarlo, mediante la funcion subset eliminaremos del dataframe tanto de la variable Producto como Cantidad todas aquellas filas donde aparezcan las palabras ENTRADA, SALIDA Y PARKING
data1 <- subset(data1, !grepl("ENTRADA|SALIDA|PARKING", data1$Cantidad, ignore.case = TRUE))
data1 <- subset(data1, !grepl("ENTRADA|SALIDA|PARKING", data1$Producto, ignore.case = TRUE))

# Bucle para reemplazar los NA con el valor de la siguiente fila
for (i in 1:(nrow(data1) - 1)) {
  if (is.na(data1$Precio_Final[i])) {
    data1$Precio_Final[i] <- data1$Precio_Final[i + 1]
  }
}

#Asignaremos la clase correspondiente a cada variable
data1$Precio_Final <- as.numeric(data1$Precio_Final)
data1$codigo_postal<- as.numeric(data1$codigo_postal)
data1$Telefono <- as.numeric(data1$Telefono)
data1$Cantidad <- as.numeric(data1$Cantidad)
data1$fecha <- as.Date(data1$fecha, format = "%d/%m/%Y")
data1 <- data1[complete.cases(data1$Cantidad), ]

#ahora arreglaremos los valores de la columna "Total" y lo convertiremos al tipo de variable que corresponde
datos_total <- data1$Total
datos_total<- gsub("[^0-9,]", "", datos_total)
data1$Total <-datos_total
#ahora cambiaremos las comas por los puntos
data1$Total <- gsub(",", ".", data1$Total)
data1$Total<- as.numeric(data1$Total)

```

```{r}
#convertimos los números en cadenas de texto
cantidades_texto <- as.character(data1$Cantidad)

#filtramos los índices donde los números terminan en "100"
indices_pan <- which(grepl("100$", cantidades_texto))
pan <- data1$Cantidad[indices_pan]
sin_ultimos_tres <- as.numeric(substr(pan, 1, nchar(pan) - 3))
data1$Cantidad[indices_pan] <-sin_ultimos_tres


ultimos_tres_numeros <- substr(pan, nchar(pan) - 2, nchar(pan))
indices2_pan <- indices_pan
pan2 <- data1$Producto[indices2_pan]
producto1_completo <- paste(ultimos_tres_numeros, pan2, sep = " ")

#asignaremos a las filas de cada producto segun el indice en que localizamos donde estaban los nuevos productos completos
data1$Producto[indices2_pan] <- producto1_completo

#convertir los números en cadenas de texto
cantidades_texto <- as.character(data1$Cantidad)

#filtrar los índices donde los números terminan en "200"
indices_servilletas <- which(grepl("200$", cantidades_texto))


servilleta <- data1$Cantidad[indices_servilletas]

sin_ultimos_tres2 <- as.numeric(substr(servilleta, 1, nchar(servilleta) - 3))
data1$Cantidad[indices_servilletas] <-sin_ultimos_tres2


ultimos_tres_numeros2 <- substr(servilleta, nchar(servilleta) - 2, nchar(servilleta))
indices2_servilletas <- indices_servilletas
servilleta2 <- data1$Producto[indices2_servilletas]
producto2_completo <- paste(ultimos_tres_numeros2, servilleta2, sep = " ")

#asignaremos a las filas de cada producto segun el indice en que localizamos donde estaban los nuevos productos completos
data1$Producto[indices2_servilletas] <- producto2_completo



# Convertir los números en cadenas de texto
cantidades_texto <- as.character(data1$Cantidad)

# Filtrar los índices donde los números terminan en "12"
indices_huevos <- which(grepl("12$", cantidades_texto))
huevos <- data1$Cantidad[indices_huevos]

sin_ultimos_dos <- as.numeric(substr(huevos, 1, nchar(huevos) - 2))
data1$Cantidad[indices_huevos] <-sin_ultimos_dos


ultimos_dos_numeros <- substr(huevos, nchar(huevos) - 1, nchar(huevos))
indices2_huevos <- indices_huevos
huevos2 <- data1$Producto[indices2_huevos]
producto3_completo <- paste(ultimos_dos_numeros, huevos2, sep = " ")
#asignaremos a las filas de cada producto segun el indice en que localizamos donde estaban los nuevos productos completos
data1$Producto[indices2_huevos] <- producto3_completo


cantidades_texto <- as.character(data1$Cantidad)
indices_cierrafacil <- which(grepl("140$", cantidades_texto))
cierrafacil <- data1$Cantidad[indices_cierrafacil]

indices2_cierrafacil <- indices_cierrafacil
cierrafacil2 <- data1$Producto[indices2_cierrafacil]
producto4_completo <- paste(cierrafacil, cierrafacil2, sep = " ")
data1$Producto[indices2_cierrafacil] <- producto4_completo


data1$Cantidad <- gsub("140$", "1", data1$Cantidad)
data1$Cantidad <- as.numeric(data1$Cantidad)

#cambiamos puntos por comas en el Producto
data1$Producto <- gsub("\\.", ",", data1$Producto)

cantidades_texto <- as.character(data1$Cantidad)
indices_codorniz <- which(grepl("18$", cantidades_texto))
codorniz <- data1$Cantidad[indices_codorniz]

sin_ultimos_dos2 <- as.numeric(substr(codorniz, 1, nchar(codorniz) - 2))
data1$Cantidad[indices_codorniz] <-sin_ultimos_dos2

ultimos_dos_numeros2 <- substr(codorniz, nchar(codorniz) - 1, nchar(codorniz))
indices2_codorniz <- indices_codorniz
codorniz2 <- data1$Producto[indices2_codorniz]
producto5_completo <- paste(ultimos_dos_numeros2, codorniz2, sep = " ")
data1$Producto[indices2_codorniz] <- producto5_completo


cantidades_texto <- as.character(data1$Cantidad)
indices_codorniz <- which(grepl("18$", cantidades_texto))
codorniz <- data1$Cantidad[indices_codorniz]

sin_ultimos_dos2 <- as.numeric(substr(codorniz, 1, nchar(codorniz) - 2))
data1$Cantidad[indices_codorniz] <-sin_ultimos_dos2

ultimos_dos_numeros2 <- substr(codorniz, nchar(codorniz) - 1, nchar(codorniz))
indices2_codorniz <- indices_codorniz
codorniz2 <- data1$Producto[indices2_codorniz]
producto5_completo <- paste(ultimos_dos_numeros2, codorniz2, sep = " ")
data1$Producto[indices2_codorniz] <- producto5_completo

medio_troceado <- which(str_detect(data1$Producto, paste("TROCEADO","PARTIDO", sep = "|") ))

producto_medio <- data1$Producto[medio_troceado]

# Función para modificar el texto según las condiciones dadas
convertir_texto_medio <- function(texto) {
  # Verificar si hay dos números al principio
  if (str_detect(texto, "^\\d{2}")) {
    # Reemplazar los dos números con "1/2"
    nuevo_texto <- str_replace(texto, "^\\d{2}", "1/2")
    return(nuevo_texto)
  }
  return(texto)  # Devolver el texto original si no cumple las condiciones
}

# Aplicar la función al vector
producto_medio_modificado <- sapply(producto_medio, convertir_texto_medio)
data1$Producto[medio_troceado]<- producto_medio_modificado
```

```{r}
cantidades_texto <- as.character(data1$Cantidad)

indice_toallitas <- which(str_detect(data1$Producto, "TOALLITAS"))
indices_toallitas <- which(grepl("50$", cantidades_texto))
toallitas <- data1$Cantidad[indices_toallitas]

sin_ultimos_dos2 <- as.numeric(substr(toallitas, 1, nchar(toallitas) - 2))
data1$Cantidad[indices_toallitas] <-sin_ultimos_dos2

ultimos_dos_numeros2 <- substr(toallitas, nchar(toallitas) - 1, nchar(toallitas))
indices2_toallitas <- indices_toallitas
toallitas2 <- data1$Producto[indices2_toallitas]
producto7_completo <- paste(ultimos_dos_numeros2, toallitas2, sep = " ")
data1$Producto[indices2_toallitas] <- producto7_completo

```


1.  A qué hora se suele ir más a comprar?

```{r}
# Separar las horas y los minutos
horas <- unique(as.numeric(sub("^(\\d+):(\\d+)$", "\\1", data1$hora)))
minutos <- unique(as.numeric(sub("^(\\d+):(\\d+)$", "\\2", data1$hora)))

# Calcular la media de las horas y los minutos
media_horas <- as.integer(mean(horas))
media_minutos <- as.integer(mean(minutos))

# Mostrar la hora media del día
print(paste("La hora media del día a la que se suele ir mas a menudo a comprar es:",
            media_horas, ":", media_minutos))
```

```{r}
library(ggplot2)
# Crear un histograma de las horas de compra
ggplot(data1, aes(x = as.numeric(sub("^(\\d+):(\\d+)$", "\\1", hora)))) +
  geom_histogram(binwidth = 1, fill = "skyblue", color = "black") +
  labs(title = "Distribución de las horas de compra",
       x = "Hora",
       y = "Frecuencia") +
  theme_minimal() +
  # Agregar una línea vertical en la hora media del día
  geom_vline(xintercept = mean(as.numeric(sub("^(\\d+):(\\d+)$", "\\1", data1$hora))), 
             color = "red", linetype = "dashed", size = 1)
```

2.  Cuál ha sido el producto más comprado?

```{r}

# Contar la cantidad de cada producto
conteo_productos <- data1 %>% 
  group_by(Producto) %>% 
  summarise(Cantidad_Total = sum(Cantidad, na.rm = TRUE)) %>% 
  arrange(desc(Cantidad_Total))
# Crear un gráfico de barras
ggplot(conteo_productos[1:10,], aes(x = reorder(Producto, -Cantidad_Total), y = Cantidad_Total)) +
  geom_bar(stat = "identity", fill = "steelblue") +
  coord_flip() +
  ylim(0,20)+
  labs(x = "Producto", y = "Cantidad Total", title = "Top 10 Productos Más Comprados") +
  theme_minimal()
```

3.  En que Mercadona se realizan más ventas?

```{r}
#ponemos librerias
library(dplyr)
library(ggplot2)

#contamos el número de compras por Mercadona
compras_merc <- data1 %>%
  group_by(Direccion, Total) %>% #agrupamos
  summarise(.groups = "drop") %>% 
  ungroup() %>%
  count(Direccion) %>% #contamos
  arrange(desc(n)) #ordenamos de forma descendente


#hacemos el grafico
ggplot(data = compras_merc, aes(x = reorder(Direccion, n), y = n)) +
  geom_bar(stat = "identity", fill = "skyblue", color = "blue") +
  labs(
    title = "Número de Compras por Mercadona",
    x = "Sucursal de Mercadona",
    y = "Número de Compras"
  ) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) #rotamos las etiquetas

```

4.  Cual es el precio medio de los tickets?

```{r}
library(ggplot2)
maximo_valor <-  max(data1$Total)
minimo_valor <- min(data1$Total)
media_valor <- mean(unique(data1$Total))
#cogeremos valores no repetidos
valores_no_repetidos <- unique(data1$Total)

# Crear intervalos de precio
intervalos <- seq(0, ceiling(max(valores_no_repetidos)/10)*10, by = 10)

# Agrupar los datos por intervalos de precio y contar la cantidad de tickets en cada intervalo
data_agrupada <- data.frame(total = valores_no_repetidos) %>%
  mutate(intervalo_precio = cut(total, breaks = intervalos, right = FALSE)) %>%
  group_by(intervalo_precio) %>%
  summarise(cantidad_tickets = n_distinct(total))

# Crear el diagrama de barras
ggplot(data_agrupada, aes(x = intervalo_precio, y = cantidad_tickets)) +
  geom_bar(stat = "identity", fill = "slateblue", color = "black") +
  labs(title = "Cantidad de Tickets por Intervalo de Precio",
       x = "Intervalo de Precio",
       y = "Cantidad de Tickets") +
  theme_minimal()

print(paste("El ticket con mayor precio es de",maximo_valor))
print(paste("El ticket con menor precio es de",minimo_valor))
print(paste("El precio medio de los tickets es",media_valor))
```

5.  En que mes se ha comprado más "x producto"?

```{r}
library(tidyverse)
library(lubridate)
#aqui me aparecen todos los productos
data_clear_producto <- data1

#Primero utilizo la funcion filter para eliminar todos los posibles na que haya en la columna Cantidad, ya que no podría trabajar con ellos.
data_clear_producto %>% filter(!is.na(Cantidad)) %>% 
  #utilizamos el mutate para crear nuestra variable mes compra y referirnos a que es el mes de la fecha de nuestro ticket
  mutate(mes_compra = month(fecha)) %>% 
  #como queremos ver para cada producto y para cada mes cuanto se han comprado, agrupamos por producto y por mes
  group_by(Producto, mes_compra) %>%
#utilizamos el summarise porque  queremos saber para cada producto, y cada mes, la cantidad de veces se ha comprado ese producto
  summarise(suma_cantidad = sum(Cantidad)) %>% 
#utilizamos el mutate y creamos la variable maximo cant que es para cada producto obtener el maximo que se ha comprado en un mes
  
  mutate(maximo_cant = max(suma_cantidad))%>% 
  #por último con filter nos quedamos solo con los productos cuya cantidad sea igual que a la maxima comprada de este producto, y así será la cantidad máxima comprada de este producto en cada mes.
  filter(maximo_cant == suma_cantidad)
  

```

6.  ¿Cómo ha variado el precio de los productos más vendidos en los últimos meses?

```{r}

library(dplyr)
library(ggplot2)

# Nos quedamos con las columnas Cantidad,Producto y Precio_Final 
ventas <- data1%>% select(c("Cantidad","Producto","Precio_Final","fecha")) 

# Calculamos el precio promedio por producto y mes
precio_promedio_por_producto_mes <- ventas %>%
  mutate(mes = format(fecha, "%Y-%m")) %>%
  group_by(Producto, mes) %>%
  summarise(precio_promedio = mean(Precio_Final, na.rm = TRUE), .groups = "drop")

# Encontramos los productos más vendidos
productos_mas_vendidos <- precio_promedio_por_producto_mes %>%
  group_by(Producto) %>%
  summarise(ventas_totales = sum(precio_promedio)) %>%
  top_n(5, ventas_totales)

# Filtramos las ventas para los productos más vendidos
ventas_productos_mas_vendidos <- ventas %>%
  filter(Producto %in% productos_mas_vendidos$Producto)

# Visualizamos la evolución del precio promedio de los productos más vendidos en los últimos meses
ggplot(ventas_productos_mas_vendidos, aes(x = fecha, y = Precio_Final, color = Producto)) +
  geom_line() +
  labs(title = "Evolución del Precio Promedio de los Productos Más Vendidos",
       x = "Fecha",
       y = "Precio Promedio") +
  theme_minimal()+
  ylim(1, NA)

```


Funcion para seleccionar las variables tipo numericas

```{r}


data_numericas<- data1 %>% select_if(is.numeric)


df_numericas_unicas <- data_numericas %>% distinct()
df_numericas_unicas
```

Funcion para seleccionar las variables tipo categoricas
```{r}
data_categoricas<- data1 %>% select_if(is.character)
data_categoricas
```

Funcion para seleccionar las variables tipo fecha

```{r}
data_fechas<- data1 %>% select_if(is.Date)
data_fechas
#

```

Funcion para mostrar un resumen de nuestro datframe
```{r}
glimpse(data1)
```

